#+TITLE: Scanning System Proposal
#+AUTHOR: Adam Washington


* Introduction

  This is a proposal for an improved system for running scans on the
  instrument.  The idea is to use =Scan= objects to represent the
  parts of the scan.  These scan objects form an algebra, making them
  easier to compose than using =for= loops.  These scan objects are
  mainly intended as tools for the instrument scientists for creating
  a higher level interface that the users will interact with.
  
* Design Goals

  We desire the following traits in the Scanning system

** User simplicity

   The users need to be able to perform simple scans without thinking
   about object orient programming or algebraic data types.
   Performing a basic scan should always be a one liner.  Making
   modified versions of that scan should require learning a
   modification of that command and not an entirely new structure.
   Common, sensible user options should be available and sane defaults
   given.

   The code should also take advantage of Python's built in
   documentation system to allow for discoverability of all of the
   functionality of these scripts.

** Composability
   
   The code should trivially allow combining smaller scripts into a
   larger script.  This ensures that, as long as the smaller scripts
   are bug free, the larger scripts will also be free of bugs by
   construction.
   
** Functionality

   The code should be able to perform all of the tasks that might
   involve scanning on the beamline, from the common place to the
   irregular.

  - Plotting :: It should be possible to plot any readback value as a
                function of any set of motor positions.  Scans of
                multiple axes should be able to either plot multiple
                labelled lines or a 2D heatmap
  - Measuring :: Performing a full series of measurements should only
                 be a minor modification of the plotting command
  - Fitting :: The user should be capable of performing fits on curves
               to extract values of interest.  Common fitting routines
               should be a simple string while still accepting custom
               functions for exceptional circumstances
  - Spacing :: It should be possible to space points both linearly and
               logarithmically.
  - Prediction :: It should be possible to estimate the time needed
                  for a scan before the scan is performed.

* Examples

  These are examples of some basic scans that the user might perform
  on the high level interface.  The examples have run on a
  [[pseudoinstrument]] defined in a later section.

** Plot Motor Scan
   
   Our first, simple example is the user plotting a scan of the
   detector intensity as the motor moves from 0 to 2 inclusively in
   steps /near/ 0.3.  

#+BEGIN_SRC python :results output :exports both
from Motor import scan

scan("theta", begin=0, end=2, stride=0.6).plot(save="plot_example.png")

#+END_SRC

#+RESULTS:
: Taking a count at theta=0.00 and two theta=0.00
: Taking a count at theta=0.50 and two theta=0.00
: Taking a count at theta=1.00 and two theta=0.00
: Taking a count at theta=1.50 and two theta=0.00
: Taking a count at theta=2.00 and two theta=0.00

  The =save= argument allows the figure to be saved to a file.
  Otherwise, the screen will show the plot interactively.
  
  [[file:plot_example.png]]

  The =stride= option gives an appoximate step size, but forces
  ensures that the beginning and final points are measured.  =step=
  forces the exact spacing, but may not measure the final point.
  =count= and =gaps= allow the user to specify the number of
  measurements and the number of gaps, respectively.
   
#+BEGIN_SRC python :results output :exports both
from Motor import scan

print("step")
scan("theta", begin=0, end=2, step=0.6).plot()
print("count")
scan("theta", begin=0, end=2, count=4).plot()
print("gaps")
scan("theta", begin=0, end=2, gaps=4).plot()

#+END_SRC

#+RESULTS:
#+begin_example
step
Taking a count at theta=0.00 and two theta=0.00
Taking a count at theta=0.60 and two theta=0.00
Taking a count at theta=1.20 and two theta=0.00
Taking a count at theta=1.80 and two theta=0.00
count
Taking a count at theta=0.00 and two theta=0.00
Taking a count at theta=0.67 and two theta=0.00
Taking a count at theta=1.33 and two theta=0.00
Taking a count at theta=2.00 and two theta=0.00
gaps
Taking a count at theta=0.00 and two theta=0.00
Taking a count at theta=0.50 and two theta=0.00
Taking a count at theta=1.00 and two theta=0.00
Taking a count at theta=1.50 and two theta=0.00
Taking a count at theta=2.00 and two theta=0.00
#+end_example

The user also has the option of fixing the steps size and number of
measurements or gaps while leaving the ending position open.

#+BEGIN_SRC python :results output :exports both
from Motor import scan

print("count")
scan("theta", begin=0, step=0.6, count=5).plot()
print("gaps")
scan("theta", begin=0, stride=0.6, gaps=5).plot()

#+END_SRC

#+RESULTS:
#+begin_example
count
Taking a count at theta=0.00 and two theta=0.00
Taking a count at theta=0.60 and two theta=0.00
Taking a count at theta=1.20 and two theta=0.00
Taking a count at theta=1.80 and two theta=0.00
Taking a count at theta=2.40 and two theta=0.00
gaps
Taking a count at theta=0.00 and two theta=0.00
Taking a count at theta=0.72 and two theta=0.00
Taking a count at theta=1.44 and two theta=0.00
Taking a count at theta=2.16 and two theta=0.00
Taking a count at theta=2.88 and two theta=0.00
Taking a count at theta=3.60 and two theta=0.00
#+end_example


** Perform Measurement Scan

   To go from a simple counting scan to a full set of measurements,
   all that needs to change is the method call.

#+BEGIN_SRC python :results output :exports both
from Motor import scan

scan("theta", begin=0, end=2, stride=0.6).measure("Taking a measurement at theta={theta} and two theta={two_theta}")

print("\nScanning two theta\n")

scan("two_theta", begin=0, end=2, stride=0.6).measure("two theta={two_theta}")

#+END_SRC

#+RESULTS:
#+begin_example
Taking a measurement at theta=0.0 and two theta=0
Taking a measurement at theta=0.5 and two theta=0
Taking a measurement at theta=1.0 and two theta=0
Taking a measurement at theta=1.5 and two theta=0
Taking a measurement at theta=2.0 and two theta=0

Scanning two theta

two theta=0.0
two theta=0.5
two theta=1.0
two theta=1.5
two theta=2.0
#+end_example

** Perform complex scans

   Some uses need more complicated measurements that just a simple
   scan over a single axis.  These more complicated commands may need
   some initial coaching from the beamline scientist, but should be
   simple enough for the user to modify them without assistance.
   
   To begin with, a user may want to scan theta and two theta together
   in lock step.

#+BEGIN_SRC python :results output :exports both
from Motor import scan

theta = scan("theta", begin=0, end=1, stride=0.3)
two_theta = scan("two_theta", begin=0, end=2, stride=0.6)
(theta & two_theta).measure("theta={theta} and two_theta={two_theta}")

#+END_SRC

#+RESULTS:
: theta=0.0 and two_theta=0.0
: theta=0.25 and two_theta=0.5
: theta=0.5 and two_theta=1.0
: theta=0.75 and two_theta=1.5
: theta=1.0 and two_theta=2.0

  On the other hand, if the user is unsure about the proper sample
  alignment, they may want to investigate theta and two-theta separately

#+BEGIN_SRC python :results output :exports both
from Motor import scan

theta = scan("theta", begin=0, end=1, stride=0.5)
two_theta = scan("two_theta", begin=0, end=3, stride=1.0)
(theta * two_theta).measure("theta={theta} and two_theta={two_theta}")

#+END_SRC

#+RESULTS:
#+begin_example
theta=0.0 and two_theta=0.0
theta=0.0 and two_theta=1.0
theta=0.0 and two_theta=2.0
theta=0.0 and two_theta=3.0
theta=0.5 and two_theta=0.0
theta=0.5 and two_theta=1.0
theta=0.5 and two_theta=2.0
theta=0.5 and two_theta=3.0
theta=1.0 and two_theta=0.0
theta=1.0 and two_theta=1.0
theta=1.0 and two_theta=2.0
theta=1.0 and two_theta=3.0
#+end_example


* Class setup

  #+Caption:  Class Diagram for the Scan Module
  [[file:classes.pdf]]
  
  The base class for the low level code is the =Scan= class.  This
  ensures that any functionality added to this class or bugs fixed in
  its code propagate out to all callers of this library.
  Unfortunately, Python does not have a concept of interfaces, so we
  cannot force all children to have a set of defined functions.
  However, any subclasses of =Scan= must contain the follow member
  functions:

  - map :: Create a modified version of the scan based on a user
           supplied function.  The original position of each point is
           fed as input to the function and the return value of the
           function is the new position.
  - reverse :: Create a copy of the scan that runs in the opposite direction
  - __len__ :: Return the number of elements in the scan
  - __iter__ :: Return an iterator that steps through the scan one
                position at a time, yielding the current position at
                each point.
		
  There are four default subclasses of Scan that should handle most of
  the requirements

** SimpleScan

   =SimpleScan= is the lowest level of the scan system.  It requires a
   function which performs the desired action on each point, a list of
   points, and a name for the axis.  At this time, all scans are
   combinations of simpleScans.

** SumScan

   =SumScan= runs two scans sequentially.  These scans do not need to
   be on the same axes or even move the same number of axes.

** ProductScan

   =ProductScan= performs every possible combination of positions for
   two different scans.  This provides an alternative to nested loops.

** ParallelScan

   =ParallelScan= takes to scans and runs their actions together at
   each step.  For example, if =a= was a scan over theta and =b= was a
   scan over two theta, then =a && b= would scan each theta angle with
   its corresponding two theta.


   
* Pseudoinstrument

  For the examples, I've created a virtual instrument so that the
  scans have something to run on.  The module Instrument.py contains
  this code.
  
#+BEGIN_SRC python :tangle Instrument.py :exports code
import numpy as np

instrument = {"theta":0, "two_theta":0}

def measure(title, info):
    """Dummy function to simulate making a measurement"""
    print(title.format(**info))

def count():
    """Dummy function to simulate taking a neutron count"""
    print("Taking a count at theta=%0.2f and two theta=%0.2f" %
          (instrument["theta"], instrument["two_theta"]))
    return np.sqrt(instrument["theta"])+instrument["two_theta"]**2

def move_theta(x):
    """move_theta is a dummy functino to simulate moving the theta motor in the examples"""
    instrument["theta"] = x

def move_two_theta(x):
    """move_two)theta is a dummy functino to simulate moving the two_theta motor in the examples"""
    instrument["two_theta"] = x

def cset(**kwargs):
    """cset is a dummy substitution of the PyGenie cset code used here for demonstration purposes"""
    if "theta" in kwargs:
        return move_theta(kwargs["theta"])
    if "two_theta" in kwargs:
        return move_two_theta(kwargs["two_theta"])
#+END_SRC
