#+TITLE: Scanning System Proposal
#+AUTHOR: Adam Washington


* Introduction

  This is a proposal for an improved system for running scans on the
  instrument.  The idea is to use =Scan= objects to represent the
  parts of the scan.  These scan objects form an algebra, making them
  easier to compose than using =for= loops.  These scan objects are
  mainly intended as tools for the instrument scientists for creating
  a higher level interface that the users will interact with.
  
* Design Goals

  We desire the following traits in the Scanning system

** User simplicity

   The users need to be able to perform simple scans without thinking
   about object orient programming or algebraic data types.
   Performing a basic scan should always be a one liner.  Making
   modified versions of that scan should require learning a
   modification of that command and not an entirely new structure.
   Common, sensible user options should be available and sane defaults
   given.

   The code should also take advantage of Python's built in
   documentation system to allow for discoverability of all of the
   functionality of these scripts.

** Composability
   
   The code should trivially allow combining smaller scripts into a
   larger script.  This ensures that, as long as the smaller scripts
   are bug free, the larger scripts will also be free of bugs by
   construction.
   
** Functionality

   The code should be able to perform all of the tasks that might
   involve scanning on the beamline, from the common place to the
   irregular.

  - Plotting :: It should be possible to plot any readback value as a
                function of any set of motor positions.  Scans of
                multiple axes should be able to either plot multiple
                labelled lines or a 2D heatmap
  - Measuring :: Performing a full series of measurements should only
                 be a minor modification of the plotting command
  - Fitting :: The user should be capable of performing fits on curves
               to extract values of interest.  Common fitting routines
               should be a simple string while still accepting custom
               functions for exceptional circumstances

* Examples

  These are examples of some basic scans that the user might perform
  on the high level interface.  The examples have run on a
  [[pseudoinstrument]] defined in a later section.

** Plot Motor Scan
   
   Our first, simple example is the user plotting a scan of the
   detector intensity as the motor moves from 0 to 2 inclusively in
   steps /near/ 0.3.  

#+BEGIN_SRC python :results output :exports both
from Motor import scan

scan("theta", begin=0, end=2, stride=0.6).plot()

#+END_SRC

#+RESULTS:
: Taking a measurement at theta=0.00 and two theta=0.00
: Taking a measurement at theta=0.50 and two theta=0.00
: Taking a measurement at theta=1.00 and two theta=0.00
: Taking a measurement at theta=1.50 and two theta=0.00
: Taking a measurement at theta=2.00 and two theta=0.00

  The =stride= option gives an appoximate step size, but forces
  ensures that the beginning and final points are measured.  =step=
  forces the exact spacing, but may not measure the final point.
  =count= and =gaps= allow the user to specify the number of
  measurements and the number of gaps, respectively.
   
#+BEGIN_SRC python :results output :exports both
from Motor import scan

print("step")
scan("theta", begin=0, end=2, step=0.6).plot()
print("count")
scan("theta", begin=0, end=2, count=4).plot()
print("gaps")
scan("theta", begin=0, end=2, gaps=4).plot()

#+END_SRC

#+RESULTS:
#+begin_example
step
Taking a measurement at theta=0.00 and two theta=0.00
Taking a measurement at theta=0.60 and two theta=0.00
Taking a measurement at theta=1.20 and two theta=0.00
Taking a measurement at theta=1.80 and two theta=0.00
count
Taking a measurement at theta=0.00 and two theta=0.00
Taking a measurement at theta=0.67 and two theta=0.00
Taking a measurement at theta=1.33 and two theta=0.00
Taking a measurement at theta=2.00 and two theta=0.00
spaces
Taking a measurement at theta=0.00 and two theta=0.00
Taking a measurement at theta=0.50 and two theta=0.00
Taking a measurement at theta=1.00 and two theta=0.00
Taking a measurement at theta=1.50 and two theta=0.00
Taking a measurement at theta=2.00 and two theta=0.00
#+end_example

The user also has the option of fixing the steps size and number of
measurements or gaps while leaving the ending position open.

#+BEGIN_SRC python :results output :exports both
from Motor import scan

print("count")
scan("theta", begin=0, step=0.6, count=5).plot()
print("gaps")
scan("theta", begin=0, stride=0.6, gaps=5).plot()

#+END_SRC

#+RESULTS:
#+begin_example
count
Taking a measurement at theta=0.00 and two theta=0.00
Taking a measurement at theta=0.60 and two theta=0.00
Taking a measurement at theta=1.20 and two theta=0.00
Taking a measurement at theta=1.80 and two theta=0.00
Taking a measurement at theta=2.40 and two theta=0.00
gaps
Taking a measurement at theta=0.00 and two theta=0.00
Taking a measurement at theta=0.72 and two theta=0.00
Taking a measurement at theta=1.44 and two theta=0.00
Taking a measurement at theta=2.16 and two theta=0.00
Taking a measurement at theta=2.88 and two theta=0.00
Taking a measurement at theta=3.60 and two theta=0.00
#+end_example

* Classes

The =Scan= class is the baseline for all measurements, but is also a
virtual class.  Every object should be a member of a subclass which
implements the following methods:

  - map :: Should take a function as its only argument.  This
             function should take the original value of the scan and
             return the new value.  =map= will return another scan
             which iterates over the new values.
  - reverse :: Creates a new scan which runs the scan in the
                 opposite direction
  - ~__len__~ :: Returns the number of measurements in the scan.
  - ~__iter__~ :: Returns a generator that steps through each of the
                  requested measurements and sets the motors to their
                  requested positions.

It should be noted that end users should *never* need to implement
their own subclass.  The goal of this library is that an algebraic
combination of simple scans will solve all of their needs.

#+BEGIN_SRC python :session mysession :tangle Scan.py
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

class Scan(object):
    def __add__(self, b):
        return SumScan(self, b)
    def __mul__(self, b):
        return ProductScan(self, b)
    def __and__(self, b):
        return ParallelScan(self, b)
    def plot(self, measurement):
        results = [(x,measurement())
                   for x in self]
        xs = [x[0] for x in results]
        ys = [x[1] for x in results]
        plt.plot(xs, ys)

class SimpleScan(Scan):
    def __init__(self, action, values):
        self.action = action
        self.values = values
    def map(self, f):
        return SimpleScan(self.action,
                          map(f, self.values))
    def reverse(self):
        return SimpleScan(self.action, self.values[::-1])
    def __iter__(self):
        for v in self.values:
            self.action(v)
            yield v
    def __len__(self):
        return len(self.values)

class SumScan(Scan):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __iter__(self):
        for x in self.a:
            yield x
        for y in self.b:
            yield y
    def __len__(self):
        return len(self.a) + len(self.b)
    def map(self, f):
        return SumScan(self.a.map(f),
                       self.b.map(f))
    def reverse(self):
        return SumScan(self.b.reverse(),
                       self.a.reverse())

class ProductScan(Scan):
    def __init__(self, a, b, mutate=lambda x, y: y):
        self.a = a
        self.b = b
        self.mutate = mutate
    def __iter__(self):
        for x in self.a:
            curry = lambda y: self.mutate(x, y)
            for y in self.b.map(curry):
                yield (x, y)
    def __len__(self):
        return len(self.a)*len(self.b)
    def map(self, f):
        return ProductScan(self.a.map(f),
                           self.b.map(f),
                           self.mutate)
    def reverse(self):
        return ProductScan(self.a.reverse(),
                           self.b.reverse(),
                           self.mutate)

class ParallelScan(Scan):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __iter__(self):
        for x, y in zip(self.a, self.b):
            yield (x, y)
    def __len__(self):
        return min(len(self.a), len(self.b))
    def map(self, f):
        return ParallelScan(self.a.map(f),
                            self.b.map(f))
    def reverse(self):
        return ParallelScan(self.a.reverse(),
                            self.b.reverse())

#+END_SRC

#+RESULTS:

* Examples 

** Pseudoinstrument

For our examples, we'll define a basic instrument with two motors:
~theta~ and ~two_theta~.  We'll also declare that there are four functions
that we can call on this instrument.

- ~move_theta~ :: Moves the theta motor to the given position
- ~move_two_theta~ :: Move the ~two_theta~ motor to the given position.
     The ~two_theta~ motor has some extra actions that it must perform
     every time it moves.
- ~measure~ :: Take a measurement with the current instrument setup
- ~get_value~ :: Returns some figure of merit for the current
                 instrument setup.

These functions aren't part of the scan system, but will be used in
our examples.

#+BEGIN_SRC python :results output :session mysession :exports both
instrument = {"theta":0, "two_theta":0}

def move_theta(x):
    instrument["theta"] = x

def move_two_theta(x):
    print("Performing extra work for two theta motor")
    instrument["two_theta"] = x

def measure():
    print("Taking a measurement at theta=%0.2f and two theta=%0.2f" %
        (instrument["theta"], instrument["two_theta"]))

from math import sin, cos

def get_value():
    return sin(instrument["theta"])*cos(instrument["two_theta"])
#+END_SRC


** Create Scans

Basic scans require two components.  The first is a function that
takes a single value and sets the motor[fn:1] to that value.  The second is
a list[fn:2] of values to perform the scan at.


A standard for loop can then iterate through the scan.  The scan
object itself will handle all of the motor movement while the body of
the loop can focus on starting the actual measurement.

#+BEGIN_SRC python :results output :session mysession :exports both

theta = SimpleScan(move_theta, [1, 2, 3])
twotheta = SimpleScan(move_two_theta, range(2,8,2))

#+END_SRC

#+RESULTS:

Let's try the scans now


#+BEGIN_SRC python :results output :session mysession :exports both
for x in theta:
    measure()
#+END_SRC
#+RESULTS:
: 
: ... Taking a measurement at theta=1.00 and two theta=0.00
: Taking a measurement at theta=2.00 and two theta=0.00
: Taking a measurement at theta=3.00 and two theta=0.00

#+BEGIN_SRC python :results output :session mysession :exports both
for x in twotheta:
    measure()
#+END_SRC

#+RESULTS:
: 
: ... Performing extra work for two theta motor
: Taking a measurement at theta=3.00 and two theta=2.00
: Performing extra work for two theta motor
: Taking a measurement at theta=3.00 and two theta=4.00
: Performing extra work for two theta motor
: Taking a measurement at theta=3.00 and two theta=6.00

** Combine Scans

Adding two scans causes the scans to run in order

#+BEGIN_SRC python :results output :session mysession :exports both
for x in (theta+twotheta):
    measure()
#+END_SRC

#+RESULTS:
: 
: ... 1
: 2
: 3
: 5
: 7
: 11
: 13


Multiplying two scans creates an inner loop for the second scan.

#+BEGIN_SRC python :results output :session mysession :exports both
for x in (twotheta*theta):
    measure()
#+END_SRC

Anding two scans causes them to run in parallel.

#+BEGIN_SRC python :results output :session mysession :exports both
for x in (theta&twotheta):
    measure()

#+END_SRC

** Reverse Scans

Reverse causes a scan to be run backward

#+BEGIN_SRC python :results output :session mysession :exports both
for x in (theta+twotheta).reverse():
    measure()
#+END_SRC

#+RESULTS:
#+begin_example

>>> >>> >>> Theta
>>> ... ... 1
2
3
Twotheta
>>> ... ... 5
7
11
13
Theta+Twotheta
>>> ... ... 1
2
3
5
7
11
13
Reverse Theta+Twotheta
>>> ... 13
11
7
5
3
2
1
Theta*Twotheta
>>> ... ... (1, 5)
(1, 7)
(1, 11)
(1, 13)
(2, 5)
(2, 7)
(2, 11)
(2, 13)
(3, 5)
(3, 7)
(3, 11)
(3, 13)
Reverse Theta*Twotheta
>>> ... ... (3, 13)
(3, 11)
(3, 7)
(3, 5)
(2, 13)
(2, 11)
(2, 7)
(2, 5)
(1, 13)
(1, 11)
(1, 7)
(1, 5)
Theta & Twotheta
>>> ... ... (1, 5)
(2, 7)
(3, 11)
Reverse Theta & Twotheta
>>> ... ... (3, 13)
(2, 11)
(1, 7)
#+end_example


** Adjust Scans

   Mapping allows scans to be manipulated by a function of one argument.

#+BEGIN_SRC python :results output :session mysession :exports both
for x in (theta+twotheta).map(lambda x: x/10):
    measure()
#+END_SRC

#+RESULTS:
#+begin_example
<bound method SimpleScan.map of <__main__.SimpleScan object at 0x7fe7658730f0>>
... ... Move Ï to 0.1
Measure
Move Ï to 0.2
Measure
Move Ï to 0.3
Measure
Move 2Ï to 0.2
Measure
Move 2Ï to 0.4
Measure
Move 2Ï to 0.6
Measure
#+end_example

   For more complex mappings, we can mutate over an inner loop.  This
   is currently the ugliest part of the library, but hopefully should be
   needed too often.  These exist for the cases where each value of
   the inner loop depends on the value before it (e.g. mapping an
   irregularly shaped space).

#+BEGIN_SRC python :results output :session mysession :exports both

scan = ProductScan(theta, twotheta, mutate=lambda x, y: x+y)
for v in scan:
    measure()

#+END_SRC

#+RESULTS:
#+begin_example

>>> ... ... Move Ï to 1
Move 2Ï to 2
Measure
Move 2Ï to 4
Measure
Move 2Ï to 6
Measure
Move Ï to 2
Move 2Ï to 2
Measure
Move 2Ï to 4
Measure
Move 2Ï to 6
Measure
Move Ï to 3
Move 2Ï to 2
Measure
Move 2Ï to 4
Measure
Move 2Ï to 6
Measure
#+end_example


** Scan Statistics

   It's possible to calculate the number of measurements in the scan.

#+BEGIN_SRC python :results output :exports both :session mysession
print(len(twotheta*(theta+theta.reverse())))
#+END_SRC

#+RESULTS:
: 18


[fn:1] Or power supply, temperature, pressure, volume, etc.
[fn:2] Any iterable can be used in place of a list

** Plotting 

The plot member function makes it trivial to screate a plot of a given
measurement's value over a scan.  Furthermore, this puts all of the
plotting code in one place, so that changes to the plotting method
(e.g. allowing for interactivity on the plots) can be made in one
central place while allowing all plotting scripts to benefit from the updates.

#+BEGIN_SRC python :results file :session mysession 

theta.plot(get_value)
plt.savefig("temp.png")

#+END_SRC

#+RESULTS:

[[file:temp.png]]

