#+TITLE: Scanning System Proposal
#+AUTHOR: Adam Washington


* Introduction

  This is a proposal for an improved system for running scans on the
  instrument.  The idea is to use =Scan= objects to represent the
  parts of the scan.  These scan objects form an algebra, making them
  easier to compose than using =for= loops.

* Classes

The =Scan= class is the baseline for all measurements, but is also a
virtual class.  Every object should be a member of a subclass which
implements the following methods:

  - map :: Should take a function as its only argument.  This
             function should take the original value of the scan and
             return the new value.  =map= will return another scan
             which iterates over the new values.
  - reverse :: Creates a new scan which runs the scan in the
                 opposite direction
  - ~__len__~ :: Returns the number of measurements in the scan.
  - ~__iter__~ :: Returns a generator that steps through each of the
                  requested measurements and sets the motors to their
                  requested positions.

It should be noted that end users should *never* need to implement
their own subclass.  The goal of this library is that an algebraic
combination of simple scans will solve all of their needs.

#+BEGIN_SRC python :session mysession :tangle Scan.py
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

class Scan(object):
    def __add__(self, b):
        return SumScan(self, b)
    def __mul__(self, b):
        return ProductScan(self, b)
    def __and__(self, b):
        return ParallelScan(self, b)
    def plot(self, measurement):
        results = [(x,measurement())
                   for x in self]
        xs = [x[0] for x in results]
        ys = [x[1] for x in results]
        plt.plot(xs, ys)

class SimpleScan(Scan):
    def __init__(self, action, values):
        self.action = action
        self.values = values
    def map(self, f):
        return SimpleScan(self.action,
                          map(f, self.values))
    def reverse(self):
        return SimpleScan(self.action, self.values[::-1])
    def __iter__(self):
        for v in self.values:
            self.action(v)
            yield v
    def __len__(self):
        return len(self.values)

class SumScan(Scan):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __iter__(self):
        for x in self.a:
            yield x
        for y in self.b:
            yield y
    def __len__(self):
        return len(self.a) + len(self.b)
    def map(self, f):
        return SumScan(self.a.map(f),
                       self.b.map(f))
    def reverse(self):
        return SumScan(self.b.reverse(),
                       self.a.reverse())

class ProductScan(Scan):
    def __init__(self, a, b, mutate=lambda x, y: y):
        self.a = a
        self.b = b
        self.mutate = mutate
    def __iter__(self):
        for x in self.a:
            curry = lambda y: self.mutate(x, y)
            for y in self.b.map(curry):
                yield (x, y)
    def __len__(self):
        return len(self.a)*len(self.b)
    def map(self, f):
        return ProductScan(self.a.map(f),
                           self.b.map(f),
                           self.mutate)
    def reverse(self):
        return ProductScan(self.a.reverse(),
                           self.b.reverse(),
                           self.mutate)

class ParallelScan(Scan):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __iter__(self):
        for x, y in zip(self.a, self.b):
            yield (x, y)
    def __len__(self):
        return min(len(self.a), len(self.b))
    def map(self, f):
        return ParallelScan(self.a.map(f),
                            self.b.map(f))
    def reverse(self):
        return ParallelScan(self.a.reverse(),
                            self.b.reverse())

#+END_SRC

#+RESULTS:

* Examples 

** Pseudoinstrument

For our examples, we'll define a basic instrument with two motors:
~theta~ and ~two_theta~.  We'll also declare that there are four functions
that we can call on this instrument.

- ~move_theta~ :: Moves the theta motor to the given position
- ~move_two_theta~ :: Move the ~two_theta~ motor to the given position.
     The ~two_theta~ motor has some extra actions that it must perform
     every time it moves.
- ~measure~ :: Take a measurement with the current instrument setup
- ~get_value~ :: Returns some figure of merit for the current
                 instrument setup.

These functions aren't part of the scan system, but will be used in
our examples.

#+BEGIN_SRC python :results output :session mysession :exports both
instrument = {"theta":0, "two_theta":0}

def move_theta(x):
    instrument["theta"] = x

def move_two_theta(x):
    print("Performing extra work for two theta motor")
    instrument["two_theta"] = x

def measure():
    print("Taking a measurement at theta=%0.2f and two theta=%0.2f" %
        (instrument["theta"], instrument["two_theta"]))

from math import sin, cos

def get_value():
    return sin(instrument["theta"])*cos(instrument["two_theta"])
#+END_SRC


** Create Scans

Basic scans require two components.  The first is a function that
takes a single value and sets the motor[fn:1] to that value.  The second is
a list[fn:2] of values to perform the scan at.


A standard for loop can then iterate through the scan.  The scan
object itself will handle all of the motor movement while the body of
the loop can focus on starting the actual measurement.

#+BEGIN_SRC python :results output :session mysession :exports both

theta = SimpleScan(move_theta, [1, 2, 3])
twotheta = SimpleScan(move_two_theta, range(2,8,2))

#+END_SRC

#+RESULTS:

Let's try the scans now


#+BEGIN_SRC python :results output :session mysession :exports both
for x in theta:
    measure()
#+END_SRC
#+RESULTS:
: 
: ... Taking a measurement at theta=1.00 and two theta=0.00
: Taking a measurement at theta=2.00 and two theta=0.00
: Taking a measurement at theta=3.00 and two theta=0.00

#+BEGIN_SRC python :results output :session mysession :exports both
for x in twotheta:
    measure()
#+END_SRC

#+RESULTS:
: 
: ... Performing extra work for two theta motor
: Taking a measurement at theta=3.00 and two theta=2.00
: Performing extra work for two theta motor
: Taking a measurement at theta=3.00 and two theta=4.00
: Performing extra work for two theta motor
: Taking a measurement at theta=3.00 and two theta=6.00

** Combine Scans

Adding two scans causes the scans to run in order

#+BEGIN_SRC python :results output :session mysession :exports both
for x in (theta+twotheta):
    measure()
#+END_SRC

#+RESULTS:
: 
: ... 1
: 2
: 3
: 5
: 7
: 11
: 13


Multiplying two scans creates an inner loop for the second scan.

#+BEGIN_SRC python :results output :session mysession :exports both
for x in (twotheta*theta):
    measure()
#+END_SRC

Anding two scans causes them to run in parallel.

#+BEGIN_SRC python :results output :session mysession :exports both
for x in (theta&twotheta):
    measure()

#+END_SRC

** Reverse Scans

Reverse causes a scan to be run backward

#+BEGIN_SRC python :results output :session mysession :exports both
for x in (theta+twotheta).reverse():
    measure()
#+END_SRC

#+RESULTS:
#+begin_example

>>> >>> >>> Theta
>>> ... ... 1
2
3
Twotheta
>>> ... ... 5
7
11
13
Theta+Twotheta
>>> ... ... 1
2
3
5
7
11
13
Reverse Theta+Twotheta
>>> ... 13
11
7
5
3
2
1
Theta*Twotheta
>>> ... ... (1, 5)
(1, 7)
(1, 11)
(1, 13)
(2, 5)
(2, 7)
(2, 11)
(2, 13)
(3, 5)
(3, 7)
(3, 11)
(3, 13)
Reverse Theta*Twotheta
>>> ... ... (3, 13)
(3, 11)
(3, 7)
(3, 5)
(2, 13)
(2, 11)
(2, 7)
(2, 5)
(1, 13)
(1, 11)
(1, 7)
(1, 5)
Theta & Twotheta
>>> ... ... (1, 5)
(2, 7)
(3, 11)
Reverse Theta & Twotheta
>>> ... ... (3, 13)
(2, 11)
(1, 7)
#+end_example


** Adjust Scans

   Mapping allows scans to be manipulated by a function of one argument.

#+BEGIN_SRC python :results output :session mysession :exports both
for x in (theta+twotheta).map(lambda x: x/10):
    measure()
#+END_SRC

#+RESULTS:
#+begin_example
<bound method SimpleScan.map of <__main__.SimpleScan object at 0x7fe7658730f0>>
... ... Move Ï to 0.1
Measure
Move Ï to 0.2
Measure
Move Ï to 0.3
Measure
Move 2Ï to 0.2
Measure
Move 2Ï to 0.4
Measure
Move 2Ï to 0.6
Measure
#+end_example

   For more complex mappings, we can mutate over an inner loop.  This
   is currently the ugliest part of the library, but hopefully should be
   needed too often.  These exist for the cases where each value of
   the inner loop depends on the value before it (e.g. mapping an
   irregularly shaped space).

#+BEGIN_SRC python :results output :session mysession :exports both

scan = ProductScan(theta, twotheta, mutate=lambda x, y: x+y)
for v in scan:
    measure()

#+END_SRC

#+RESULTS:
#+begin_example

>>> ... ... Move Ï to 1
Move 2Ï to 2
Measure
Move 2Ï to 4
Measure
Move 2Ï to 6
Measure
Move Ï to 2
Move 2Ï to 2
Measure
Move 2Ï to 4
Measure
Move 2Ï to 6
Measure
Move Ï to 3
Move 2Ï to 2
Measure
Move 2Ï to 4
Measure
Move 2Ï to 6
Measure
#+end_example


** Scan Statistics

   It's possible to calculate the number of measurements in the scan.

#+BEGIN_SRC python :results output :exports both :session mysession
print(len(twotheta*(theta+theta.reverse())))
#+END_SRC

#+RESULTS:
: 18


[fn:1] Or power supply, temperature, pressure, volume, etc.
[fn:2] Any iterable can be used in place of a list

** Plotting 

The plot member function makes it trivial to screate a plot of a given
measurement's value over a scan.  Furthermore, this puts all of the
plotting code in one place, so that changes to the plotting method
(e.g. allowing for interactivity on the plots) can be made in one
central place while allowing all plotting scripts to benefit from the updates.

#+BEGIN_SRC python :results file :session mysession 

theta.plot(get_value)
plt.savefig("temp.png")

#+END_SRC

#+RESULTS:

[[file:temp.png]]

